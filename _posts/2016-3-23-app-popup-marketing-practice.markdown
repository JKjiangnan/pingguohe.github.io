---

layout: post
title: App 动态弹窗营销方案实践
author: Longerian

---

在电商类应用里，运营小二经常需要某个页面配合节日、活动等特殊事件去做一些营销氛围，又或者是卖家需要在他的店铺内和消费者进行一些互动营销玩法。传统的交互方式往往是在页面内某处引导用户打开一个新的 H5 页面进行互动，但这种方式割裂了互动营销和原始页面。从去年双十一前开始，我们就引入了一种弹窗的交互方式让运营小二或者店铺卖家在他期望的页面上直接做营销活动，这种弹窗的方式具备更佳的浸入式体验，同时也提供了更多的营销手段，在双十一及后续的活动中承担了非场重要的角色，现已成为阿里淘系应用里最重要的营销工具之一。

## 实现方案——基本雏形

以 Android 平台为例，说起弹窗，让人很容易想到的就是```Dialog```、```PopUpWindow```、```WindowManager```，或者 dialog 风格的```Activity```。这些实现方案会有以下一种或几种不足：
	
* 影响了用户与原有页面的交互
* 弹窗本身很难与原有页面通信
* 可能会入侵原有页面的代码
	
很多时候，强制弹窗，影响用户交互的行为是令人反感的；入侵弹窗页面的代码实现方案也是难以跟上发版节奏和运营需求的。我们采用的是在每个```Activity```的根节点里增加一层```WebView```，覆盖在原有页面之上，并且拦截、控制拦截触摸事件，可以将事件传递给原有页面，不影响原有页面的点击、滑动操作，从而达到弹窗与页面相互融合的境界。为了达到动态化、无业务代码侵入，将整体实现方案打包在一个模块内，配合我们的[配置中心](http://pingguohe.net/2016/03/18/config-center.html)，真正达到灵活部署的地步。具体来说，整个方案有以下几个要点：

* 触发弹窗的时机一般有两种：一种是在切换到新页面时自动弹出，另一种是再当前页面用户产生交互之后触发弹出。前者通过监听页面切换生命周期事件来触发，后者通过发广播、监听广播来触发。
* 弹窗的控制是通过规则配置，规则的主要内容包括『宿主页面』、『弹窗内容 URL』、『弹窗时间段』、『弹窗次数』、『点透阈值』等；一个弹窗活动的配置项内容大致如下，在整个弹窗配置模块里，会有多个这样的配置项存在，代表多个线上活动。
	
	```
	{
		"uri":"com.tmall.android.XXActivity", //通过页面切换触发时，配置的是页面的类名；通过广播消息触发时，配置的是标识消息的一个唯一 id；
		"url":"http://www.tmall.com/", //弹出的H5页面url
		"modalThreshold":0.5, // 可以点透的透明度阈值
		"appear":false, // 如果是false，就按下面的时间决定是否弹出，如果为true则不看下面的时间
		"startTime":"2016-04-21 00:00:00",
		"endTime":"2016-05-01 00:00:00",
       	"times":0 // 弹出次数，0为不限
	}
	```
* 通过页面切换触发弹窗，需要监听```ActivityLifecycleCallbacks```，在其```onActivityResumed()```方法里检查配置规则：
	1. 遍历上述活动配置项
	2. 检查 uri 字段与当前 activity 类名否一致
	3. 检查该活动弹窗次数有无超出限制
	4. 检查活动是否有效期内
	
	当查找到第一个符合2、3、4条件的活动配置时，就返回这个配置项，准备弹窗。
	
	```
    View webview = activity.getWindow().findViewById(R.id.webview_container_id);
    if (null != webview) {
        //若已经存在一个弹窗，则不在加载新的弹窗
        return;
    }
    WebViewContainer wvContainer = new WebViewContainer(activity);
    wvContainer.setId(R.id.webview_container_id);
    wvContainer.setVisibility(View.INVISIBLE);
    WebView wvwebview = buildWebView(activity, config);
    wvContainer.setPenetrateAlpha((int) (config.getModalThreshold() * 255));
    activity.getWindow().addContentView(wvContainer, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
    wvContainer.loadUrl(config.getUrl());
	```
	
	当页面退出时，系统会回调```onActivityPaused()```方法里，在这里再删除可能存在的弹窗；

* 通过广播来触发弹窗，需要监听自定义```LocalBroadcast```，流程与上述步骤一样，只是检查规则的时候，第2步不再检查页面类名，而是检查广播里传递过来的唯一 id。
* ```WebView```及内部 H5 页面的背景一般是透明的，这样不影响与宿主页面的交互，```WebView```外面其实包裹了一层```FrameLayout```，用来控制触摸事件的传递，它会获取所点击处的 H5 内容的透明度，和『点透阈值』比对，如果透明度超出了阈值，将事件传递给宿主页面，表明该区域可点透，否则让 H5 页面消化掉；
	
	```
    public boolean onInterceptTouchEvent(MotionEvent event) {
        try {
            ...
            final int pixel = getDrawingCache().getPixel((int) event.getX(), (int) event.getY());
            final int alpha = 255 - Color.alpha(pixel);
            if (alpha > mPenetrateAlpha)
                return true;
            return false;
        } catch (Throwable e) {
            return true;
        }
    }
	```
	
* 弹窗被添加之后，默认是不可见的，如上文代码所示。需要在 H5 页面加载完之后，调用hybrid接口显示出来；比如网络错误、页面有 bug 之类的问题，可以避免用户看到这类错误信息；
* 弹窗次数限制由『弹窗次数』规则里控制，H5 页面在显示出来的时候需要调用相应的 hybrid 接口去加1；
* 『弹窗时间段』规则控制了弹窗的时间，如果打开页面是在该时间段内，符合其他规则的弹窗将会直接弹窗；如果是打开页面是在该时间段前，还能定时弹出；
* 每个宿主页面只加载一层弹窗，防止引起性能问题或者管理错乱；

![实现方案——基本雏形](https://img.alicdn.com/tps/TB1G7lbMXXXXXacapXXXXXXXXXX-493-196.png)

通过这样几条规则的灵活控制，外加[配置中心](http://pingguohe.net/2016/03/18/config-center.html)动态调整规则的能力，可以方便地为具体某个页面增加弹窗的营销能力，而 H5 页面的内容是天生具备动态能力的，整体配合起来就提供了一套完整的运营平台。从去年双十一开始的『红包雨』、『下雪氛围』、『春节舞龙』等等一系列活动，都是在这个平台上承载的。

![dragon](https://gw.alicdn.com/tps/TB1P3N4MXXXXXbKXpXXXXXXXXXX-270-405.png)
![padan](https://gw.alicdn.com/tps/TB1lT4QMXXXXXbmXVXXXXXXXXXX-270-405.png)

当然，通过```WebView```来弹窗，也比传统的弹窗功能多了一些不确定的因素。首先```WebView```本身在线上存在少量异常，webview 出错，弹窗自然也弹不出来了；还有假如低配手机上内存不足，可能也会影响弹窗；不过这些还是小概率的，比较普遍的是弱网下，H5 页面加载比较慢，影响用户体验。从运行半年多的经验来看，crash倒是没有，稳定性还挺高的，偶尔有几个活动有舆情反馈谁看不到弹窗。所以这方面，还有一些优化手段也在继续做：一是升级```WebView```控件为的```UCWebView```，速度更快、内存消耗更少；二是 H5 页面缓存包提前下发，用户设备就可以直接加载本地页面文件，而不需要联网下载。

## 再进一步——提升动态能力

通过配置规则控制弹窗，对于弹窗行为来说，是可以达到动态化的，但是配置规则本身还是静态的，也就是说，所有用户拿到的都是同一份规则，他们会看到同样的内容，当运营想要精细化运营，针对不同的用户或者选择性的选取一部分用户弹窗的时候，规则本身就满足不了这种个性化要求。还有一种更复杂的情况，那就是一个页面在同一个时间都内要承载多个营销活动，有的是个性化，有的是通用的，由于每次只能弹一个窗，那就需要根据业务优先级弹选择一个优先级最高的活动弹窗。总结起来就是要还需要进一步增强动态能力。

基于现有规则，一种可行的方案是让符合规则页面都先弹窗加载 H5 页面，上文提到弹窗被添加之后，默认是不可见的，需要在 H5 页面加载完之后，调用接口显示。那么就可以让 H5 页面调用后台接口来判断要不要针对该用户展示内容，或者让它作为中转页，去承接不同的活动内容，选择一个优先级最高的展示。这样做不好的地方在于需要个性化弹窗的页面都得挂一个这样的控制的中转页面。我们希望动态能力统一收敛在整个弹窗管理体系里，而不是再分散出去到另一个环节。

幸运的是，我们还有[Airtrack](http://pingguohe.net/2016/03/22/abtest-in-tmall.html)、状态中心，前者具备个性化的逻辑分区能力，比如能按地区选取用户；后者能提供用户具体的活动状态，比如他/她是不是新用户，最近的活跃度如何；甚至我们的客户端还有用户实际使用场景的物理状态感知能力，在后续还能进一步丰富触发弹窗的场景。客户端通过对接这些具备动态能力的 sdk，配合原有规则，就可以增强动态弹窗能力了。比如与状态中心对接时，我们就在原有的活动规则基础之上增加状态码以及期望的状态值，当触发弹窗时，除了检查上文提到的几个静态规则，再去状态中心检查获取一下当前的真实状态，如果这些所有条件都符合，才触发弹窗。在最近的新人礼包活动、三八活动等一系列活动井喷的阶段里，我们就是这么来管理多个业务的。

![再进一步——提升动态能力](https://img.alicdn.com/tps/TB1F2JkMXXXXXb9XVXXXXXXXXXX-566-451.png)

## 更上一层楼——体系化

通过之前的各种配置中心、状态中心等系统的配置，动态弹窗能力有了很大的保障。但是这些系统都是面向开发的，而弹窗的业务往往是运营发起的，让运营来操作这些开发系统，经过实践检验，那是不现实的。所以目前的活动发布、上下线，都是开发在维护，而对于运营来说，还不够灵活，不能做到想上就上、想下就下、灵活排期。也就是说，在日常运营维护过程中，还不具备足够的动态能力。因此，我们正在做一套运营系统，面向运营，把这些开发系统对接起来，进一步提高生成力。

![更上一层楼——体系化](https://img.alicdn.com/tps/TB1A6phMXXXXXceXVXXXXXXXXXX-903-469.png)

## 总结

回顾最初的实现方案，发现弹窗只是一个基本的功能诉求，实现原理也比较简单，当然其中也踩过很多坑；但是随着后来业务的发展，就慢慢提升了整个功能的丰富度，也从单一功能做成了整个体系，整体的价值也就慢慢体现出来了。